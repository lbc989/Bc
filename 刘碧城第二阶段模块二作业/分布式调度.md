**分布式调度**

​        任务调度是指基于给定的时间点，给定的时间间隔或者给定执行次数自动的执行任务。任务调度是是操作系统的重要组成部分，而对于实时的操作系统，任务调度直接影响着操作系统的实时性能。任务调度涉及到多线程并发、运行时间规则定制及解析、线程池的维护等诸多方面的工作。

​        WEB服务器在接受请求时，会创建一个新的线程服务。但是资源有限，必须对资源进行控制，首先就是限制服务线程的最大数目，其次考虑以线程池共享服务的线程资源，降低频繁创建、销毁线程的消耗；然后任务调度信息的存储包括运行次数、调度规则以及运行数据等。一个合适的任务调度框架对于项目的整体性能来说显得尤为重要。
**特点**

1、多个实例协调工作，一个实例挂掉了，另一个继续接上，不会执行重复的任务

2、轻量级：1）All in jar，必要依赖仅仅zookeeper

​                      2）并非独立部署的中间件，就是jar程序

3、去中心化：1）执行节点对等

​                            （程序和jar一样，唯一不一样的可能是分片）

​                          2）定时调度自触发（没有中心调度节点分配）

​                          3）服务自发现（过注册中心的服务发现）

​                          4）主节点非固定

4、任务分片：不同的实例处理不同的分片，可弹性扩容

**Elastic-job-lite**

​        框架使用zookeeper作为注册中心，Elastic-job-lite框架通过监听感知zookeeper数据的变化，并做相应的处理；运维平台也仅是通过读取zk数据来展现作业状态，或是更新zk数据修改全局配置。运维平台和Elastic-job-lite没有直接的关系，完全解耦合。Elastic-job-lite并不直接提供数据处理的功能，框架只会将分片项分配给各个正在运行中的服务器，分片项与真是数据的对应关系需要开发者在应用程序中自行处理。

​        Elastic-job-lite并无作业调度中心节点，而是基于部署作业框架的程序在到达相应时间点时各自触发调度。注册中心仅用于作业注册和监控信息存储，而主作业节点仅用于处理分片和清理的功能。

​       1） 该框架在zookeeper上的节点

​        首先注册中心在命名的空间下创建作业名称节点（作业名称用来区分不同的作业，一旦修改名称，则认为是新的作业），作业名称节点下又包含5个子节点：

config：保存作业的配置信息，以JSON格式存储

sharding：保存作业的分片信息，它的子节点是分片项序号，从零开始，至分片总数减一

leader：该节点保存作业服务器主节点的信息，分为election、sharding和failover三个子节点，分别用于主节点的选举、分片和失效转移

instances：该节点保存的是作业运行实例的信息，子节点是当前作业运行实例的主键

servers：该节点保存作业服务器的信息，子节点是作业服务器的IP地址

​        2）实现原理

​        第一台服务器上线触发主服务器选举，主服务器一旦下线，则重新触发选举，选举过程中阻塞，只有当主服务器选举完成，才会去执行其他的任务；

​        某服务器上线时会自动将服务器的信息注册到注册中心，下线时会自动更新服务器的状态；

​        主节点选举，服务器上下线，分片总数变更均更新重新分片标记；

​        定时任务触发时，如需重新分片，则通过主服务器分片，分片过程中阻塞，分片结束后才可以执行任务。如分片过程中主服务器下线，则先选举主服务器在分片；
​        由上一项说明可知，为了维持作业运行时的稳定性，运行过程中只会标记分片的状态，不会重新分片，分片仅可能发生在下次任务触发前；
​        每次分片都会按照ip排序，保证分片结果不会产生较大的波动；实现失效转移功能，在某台服务器执行完毕后主动抓取未分配的分片，并且在某台服务器下线后主动寻找可用的服务器执行任务。
​        elastic底层的任务调度还是使用的quartz，通过zookeeper来动态给job节点分片。如果很大体量的用户需要我们在特定的时间段内计算完成，那么我们肯定是希望我们的任务可以通过集群达到水平的扩展，集群里的每个节点都处理部分的用户，不管用户的数量有多大，我们只需要增加机器就可以了。举个例子：比如我们希望3台机器跑job，我么将我们的任务分成3片，框架通过zk的协调，最终会让3台机器分配到0，1，2的任务片，比如server0->0、server1->1、server2->2，当server0执行时，可以只查询id%3==0的用户，server1可以只查询id%3==1的用户，server2可以只查询id%3==2的用户。

​        在以上的基础上再增加一个server3，此时，server3分不到任何的分片，没有分到任务分片的程序将不执行。如果此时server2挂了，那么server2被分到的任务分片将会分配给server3，所以server3就会代替server2执行。如果此时server3也挂了，那么框架也会自动的将server3的任务分片随机分配到server0或者server1，那么就可能成：server0->0、server1->1,2。

这种特性称之为弹性扩容。
